## 单源最短路径

在最短路径问题中，我们给定一个带权重的有向图 G = (V, E) 和权重函数 w: E -> R，该权重函数将每条边映射到实数值的权重上。图中一条路径 p = <v<sub>0</sub>, v<sub>1</sub>, ..., v<sub>k</sub>> 的权重 w(p) 是构成该路径的所有边的权重之和：

w(p) = ∑<sub>i=1</sub><sup>k</sup>w(v<sub>i-1</sub>, v<sub>i</sub>)

定义从结点 u 到结点 v 的最短路径权重 δ(u, v) 如下：

![](../assets/images/graph-algorithms/single-source-shortest-path1.png)

从结点 u 到结点 v 的最短路径则定义为任何一条权重为 w(p) = δ(u, v) 的从 u 到 v 的路径 p。当然，边上的权重也可以代表非距离的度量单位，如时间、成本、罚款、损失，或者任何其它可以随路径长度的增加而线性积累的数量以及我们想要最小化的数量。

广度优先搜索算法就是一个求取最短路径的算法，但该算法只能用于无权重的图，即每条边的权重都是单位权重的图。

#### 最短路径的几个变体

我们集中精力讨论单源最短路径问题：给定一个图 G = (V, E)，我们希望找到从给定源结点 s ∈ V 到每个结点 v ∈ V 的最短路径。单源最短路径问题可以用来解决许多其它问题，其中就包括下面的几个最短路径的变体问题。

单目的地最短路径问题：找到从每个结点 v 到给定目的地结点 t 的最短路径。如果将图的每条边的方向翻转过来，我们就可以将这个问题转换为单源最短路径问题。

单结点对最短路径问题：找到从给定结点 u 到给定结点 v 的最短路径。如果解决了针对单个结点 u 的单源最短路径问题，那么也就解决了这个问题。而且，在该问题的所有已知算法中，最坏情况下的渐进运行时间都和最好的单源最短路径算法的运行时间一样。

所有结点对最短路径问题：对于每对结点 u 和 v，找到从结点 u 到结点 v 的最短路径。虽然可以针对每个结点运行一遍单源最短路径算法，但通常可以更快地解决这个问题。

#### 最短路径的最优子结构

最短路径算法通常依赖最短路径的一个重要性质：两个结点之间的一条最短路径包含着其它的最短路径，最优子结构是可以使用动态规划和贪心算法的一个重要指标。Dijkstra 算法就是一个贪心算法，而 Floyd-Warshall 算法则是一个动态规划算法，该算法能够找出所有结点对之间的最短路径。下面的引理精确地叙述了最短路径的最优子结构性质。

引理（最短路径的子路径也是最短路径）：给定带权重的有向图 G =(V, E) 和权重函数 w: E -> R。设 p = <v<sub>0</sub>, v<sub>1</sub>, ..., v<sub>k</sub>> 为结点 v<sub>0</sub> 到结点 v<sub>k</sub> 的一条最短路径，并且对于任意的 i 和 j，0 <= i <= j <= k，设 p<sub>ij</sub> = <v<sub>i</sub>, v<sub>i+1</sub>, ..., <sub>j</sub>> 为路径 p 中从结点 v<sub>i</sub> 到结点 v<sub>j</sub> 的子路径，那么 p<sub>ij</sub> 是从结点 v<sub>i</sub> 到结点 v<sub>j</sub> 的一条最短路径。

证明：如果将路径 p 分解为 v<sub>0</sub> --p<sub>0i</sub>--> v<sub>i</sub> --p<sub>ij</sub>--> v<sub>j</sub> --p<sub>jk</sub>--> v<sub>k</sub>，则有 w(p) = w(p<sub>0i</sub>) + w(p<sub>ij</sub>) + w(p<sub>jk</sub>)。现在，假设存在一条从 v<sub>i</sub> 到 v<sub>j</sub> 的路径 p<sub>ij</sub>'，且 w(p<sub>ij</sub>') < w(p<sub>ij</sub>)，则 v<sub>0</sub> --p<sub>0i</sub>--> v<sub>i</sub> --p<sub>ij</sub>'--> v<sub>j</sub> --p<sub>jk</sub>--> v<sub>k</sub> 是一条从结点 v<sub>0</sub> 到结点 v<sub>k</sub> 的权重为 w(p<sub>0i</sub>) + w(p<sub>ij</sub>') + w(p<sub>jk</sub>) 的路径，而该权重小于 w(p)。这与 p 是从 v<sub>0</sub> 到 v<sub>k</sub> 的一条最短路径这一假设矛盾。

#### 负权重的边

某些单源最短路径问题可能包括权重为负值的边。但如果图 G = (V, E) 不包含从源结点 s 可以到达的权重为负值的环路，则对于所有的结点 v ∈ V，最短路径权重 δ(s, v) 都有精确定义，即使其取值是负数。如果图 G 包含从 s 可以到达的权重为负值的环路，则最短路径权重无定义。从 s 到该环路上的任意结点的路径都不可能是最短路径，因为我们只要沿着任何“最短”路径再遍历一次权重为负值的环路，则总是可以找到一条权重更小的路径。如果从结点 s 到结点 v 的某条路径上存在权重为负值的环路，我们定义 δ(s, v) = -∞。

下图描述的是负权重和权重为负值的环路对最短路径权重的影响。因为从结点 s 到结点 a 只有一条路径（路径 <s, a>），所以有 δ(s, a) = w(s, a) = 3。类似地，从结点 s 到结点 b 也只有一条路径，因此 δ(s, b) = w(s, a) + w(a, b) = 3 + (-4) = -1。从结点 s 到结点 c 则有无数条路径：<s, c>, <s, c, d, c>, <s, c, d, c, d, c> 等。因为环路 <c, d, c> 的权重为 6 + (-3) = 3 > 0，从结点 s 到结点 c 的最短路径是 <s, c>，其权重为 δ(s, c) = w(s, c) = 5.类似地，从结点 s 到结点 d 的最短路径为 <s, c, d>，其权重为 δ(s, d) = w(s, c) + w(c, d) = 11.类似地，从结点 s 到结点 e 也有无数条路径：<s, e>, <s, e, f, e>, <s, e, f, e, f, e> 等等。因为环路 <e, f, e> 的权重为 3 + (-6) = -1 < 0，从结点 s 到结点 e 没有最短路径。通过遍历负权重环路 <e, f, e> 任意次数，可以找打权重为任意负值的从结点 s 到结点 e 的路径，因此 δ(s, e) = -∞。类似地，δ(s, f) = -∞。因为结点 g 可以从结点 f 到达，我们可以找到一条权重为任意负值的从结点 s 到结点 g 的路径，因此 δ(s, g) = -∞。结点 h、i 和 j 也形成一个权重为负值的环路，但它们不能从结点 s 到达，因此，δ(s, h) = δ(s, i) = δ(s, j) = ∞。

![](../assets/images/graph-algorithms/single-source-shortest-path2.png)

有向图中的负权重边。从源结点 s 到每个结点之间的最短路径的权重标记在每个结点中。因为结点 e 和结点 f 形成一个权重为负值且可以从结点 s 到达的环路，它们的最短路径权重为 -∞。因为结点 g 可以从一个最短路径权重为 -∞ 的结点到达，它的最短路径权重也是 -∞。结点 h、i 和 j 不能从源结点 s 到达，因此，它们的最短路径权重为 ∞，即使它们也在一条权重为负值的环路上。

某些最短路径算法（如 Dijkstra 算法）假设输入图的所有的边权重为非负值。例如，道路交通图的例子中所有权重都为正值。另外一些算法（如 Bellman-Ford）算法，允许输入图中包含负权重的边，但只要没有可以从源结点到达的权重为负值的环路，就可以生成正确的答案。在通常情况下，如果存在一条权重为负值的环路，Bellman-Ford 算法可以侦测并报告其存在。

#### 环路












































